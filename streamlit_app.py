import streamlit as st
import requests
import json
from datetime import datetime
import os
import time
import subprocess

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="ETL Documentos - Sistema Completo",
    page_icon="üìÑ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# URLs da API
# Detecta se est√° rodando no Docker
if os.path.exists('/.dockerenv'):
    # Se est√° no Docker, usa o nome do servi√ßo
    API_BASE_URL = "http://etl-api:8000/api/v1"
else:
    # Se est√° local, usa localhost
    API_BASE_URL = "http://localhost:8000/api/v1"

# Inicializar session state
if 'api_key' not in st.session_state:
    st.session_state.api_key = None
if 'cliente_info' not in st.session_state:
    st.session_state.cliente_info = None
if 'authenticated' not in st.session_state:
    st.session_state.authenticated = False
if 'logs' not in st.session_state:
    st.session_state.logs = []
if 'processing' not in st.session_state:
    st.session_state.processing = False
if 'live_logs' not in st.session_state:
    st.session_state.live_logs = []


def add_log(message, level="INFO"):
    """Adiciona log √† sess√£o"""
    timestamp = datetime.now().strftime("%H:%M:%S")
    log_entry = f"[{timestamp}] {level}: {message}"
    st.session_state.logs.append(log_entry)
    # Manter apenas os √∫ltimos 100 logs
    if len(st.session_state.logs) > 100:
        st.session_state.logs = st.session_state.logs[-100:]


def add_live_log(message, level="INFO"):
    """Adiciona log em tempo real"""
    timestamp = datetime.now().strftime("%H:%M:%S.%f")[:-3]
    log_entry = f"[{timestamp}] {level}: {message}"
    st.session_state.live_logs.append(log_entry)
    # Manter apenas os √∫ltimos 50 logs para a tela
    if len(st.session_state.live_logs) > 50:
        st.session_state.live_logs = st.session_state.live_logs[-50:]


def get_docker_logs():
    """Captura logs do container da API em tempo real"""
    try:
        result = subprocess.run(
            ["docker", "logs", "--tail", "10",
                "--since", "5s", "etl-documentos-api"],
            capture_output=True,
            text=True,
            timeout=3
        )

        if result.returncode == 0:
            logs = result.stdout + result.stderr
            parsed_logs = []

            for log in logs.split('\n'):
                if not log.strip():
                    continue

                # Extrair mensagens importantes
                if '"message":' in log:
                    try:
                        log_data = json.loads(log)
                        message = log_data.get('message', '')
                        level = log_data.get('level', 'INFO')

                        # Filtra mensagens importantes
                        important_keywords = [
                            'tentando extra√ß√£o', 'docling', 'azure', 'fallback',
                            'classifica√ß√£o', 'processamento', 'converting document',
                            'finished converting', 'erro azure', 'openai'
                        ]

                        if any(keyword.lower() in message.lower() for keyword in important_keywords):
                            timestamp = log_data.get('timestamp', '')
                            if timestamp:
                                timestamp = timestamp.split(
                                    'T')[1][:8]  # HH:MM:SS
                            parsed_logs.append(
                                f"[{timestamp}] {level}: {message}")

                    except json.JSONDecodeError:
                        continue
                elif 'Processing document' in log:
                    doc_name = log.split('Processing document')[1].strip()
                    parsed_logs.append(f"üîÑ Processando: {doc_name}")
                elif 'Finished converting' in log and 'in' in log:
                    time_info = log.split('in')[-1].strip()
                    parsed_logs.append(f"‚úÖ Convers√£o conclu√≠da em {time_info}")

            return parsed_logs
        return []
    except Exception as e:
        return [f"Erro ao capturar logs: {str(e)}"]


def clear_logs():
    """Limpa os logs"""
    st.session_state.logs = []


def clear_live_logs():
    """Limpa os logs em tempo real"""
    st.session_state.live_logs = []


def check_api_health():
    """Verifica se a API est√° online"""
    try:
        response = requests.get(f"{API_BASE_URL}/health", timeout=10)
        return response.status_code == 200
    except:
        return False


def create_client(nome, email, senha, plano):
    """Cria um novo cliente"""
    try:
        response = requests.post(
            f"{API_BASE_URL}/clientes/",
            json={"nome": nome, "email": email,
                  "senha": senha, "plano": plano},
            timeout=15
        )
        return response.status_code == 201, response.json()
    except Exception as e:
        return False, str(e)


def authenticate_client(api_key):
    """Autentica cliente e retorna dados de uso"""
    headers = {"Authorization": f"Bearer {api_key}"}
    try:
        response = requests.get(
            f"{API_BASE_URL}/clientes/me/usage", headers=headers, timeout=15)
        if response.status_code == 200:
            return True, response.json()
        else:
            return False, response.text
    except Exception as e:
        return False, str(e)


def get_client_quotas(api_key):
    """Obt√©m quotas do cliente"""
    headers = {"Authorization": f"Bearer {api_key}"}
    try:
        response = requests.get(
            f"{API_BASE_URL}/clientes/me/quotas", headers=headers, timeout=15)
        if response.status_code == 200:
            return True, response.json()
        else:
            return False, response.text
    except Exception as e:
        return False, str(e)


def process_document_with_logs(api_key, file):
    """Processa documento com logs simples"""
    headers = {"Authorization": f"Bearer {api_key}"}

    try:
        add_live_log("üöÄ Iniciando processamento...", "INFO")
        add_live_log(
            f"üìÅ Arquivo: {file.name} ({len(file.read())} bytes)", "INFO")
        file.seek(0)

        add_live_log("üì§ Enviando arquivo para a API...", "INFO")

        files = {"arquivo": (file.name, file, "application/octet-stream")}
        start_time = time.time()

        response = requests.post(
            f"{API_BASE_URL}/processar",
            headers=headers,
            files=files,
            timeout=180
        )

        processing_time = time.time() - start_time
        add_live_log(
            f"‚è±Ô∏è Processamento conclu√≠do em {processing_time:.2f}s", "SUCCESS")

        if response.status_code == 200:
            result = response.json()
            add_log("‚úÖ Documento processado com sucesso!", "SUCCESS")
            add_live_log("‚úÖ Processamento bem-sucedido!", "SUCCESS")
            return True, result
        else:
            error_msg = f"Erro {response.status_code}: {response.text}"
            add_log(f"‚ùå {error_msg}", "ERROR")
            add_live_log(f"‚ùå {error_msg}", "ERROR")
            return False, error_msg

    except requests.exceptions.Timeout:
        error_msg = "‚ùå Timeout: Processamento demorou muito tempo"
        add_log(error_msg, "ERROR")
        add_live_log(error_msg, "ERROR")
        return False, error_msg
    except Exception as e:
        error_msg = f"‚ùå Erro: {str(e)}"
        add_log(error_msg, "ERROR")
        add_live_log(error_msg, "ERROR")
        return False, error_msg


def display_live_logs():
    """Exibe logs em tempo real"""
    if st.session_state.live_logs:
        st.subheader("üì° Logs em Tempo Real")

        # Container com altura fixa e scroll
        logs_container = st.container(height=350)
        with logs_container:
            for log in st.session_state.live_logs[-20:]:  # √öltimos 20 logs
                if "ERROR" in log:
                    st.error(log)
                elif "SUCCESS" in log:
                    st.success(log)
                elif "WARNING" in log:
                    st.warning(log)
                elif "üîÑ" in log or "üì§" in log or "‚úÖ" in log:
                    st.info(log)
                else:
                    st.text(log)


def upgrade_plan(api_key, novo_plano):
    """Faz upgrade do plano do cliente"""
    headers = {"Authorization": f"Bearer {api_key}"}
    try:
        response = requests.put(
            f"{API_BASE_URL}/clientes/me/upgrade-plan",
            json={"novo_plano": novo_plano},
            headers=headers,
            timeout=15
        )
        if response.status_code == 200:
            return True, response.json()
        else:
            return False, response.text
    except Exception as e:
        return False, str(e)


def main():
    st.title("üîç ETL Documentos - Sistema Completo")
    st.markdown(
        "**Sistema de processamento inteligente com rastreabilidade de clientes**")

    # Verificar API
    api_ok = check_api_health()

    # Sidebar principal
    with st.sidebar:
        st.header("üîê Autentica√ß√£o")

        if not api_ok:
            st.error("‚ùå API N√£o Conectada")
            st.info("Certifique-se de que a API est√° rodando na porta 8000")
            return

        st.success("‚úÖ API Conectada")

        # Tabs para autentica√ß√£o
        auth_tab1, auth_tab2 = st.tabs(["üîë Login", "‚ûï Novo Cliente"])

        with auth_tab1:
            st.subheader("Login com API Key")

            api_key = st.text_input(
                "API Key",
                type="password",
                placeholder="etl_...",
                help="Cole sua API Key aqui"
            )

            if st.button("üîì Entrar", type="primary", key="login_button"):
                if api_key:
                    with st.spinner("Autenticando..."):
                        add_log("Tentando autentica√ß√£o...")
                        success, result = authenticate_client(api_key)
                        if success:
                            st.session_state.api_key = api_key
                            st.session_state.cliente_info = result
                            st.session_state.authenticated = True
                            add_log("‚úÖ Autentica√ß√£o bem-sucedida!", "SUCCESS")
                            st.success("‚úÖ Autenticado com sucesso!")
                            st.rerun()
                        else:
                            add_log(
                                f"‚ùå Falha na autentica√ß√£o: {result}", "ERROR")
                            st.error(f"‚ùå Erro na autentica√ß√£o: {result}")
                else:
                    st.warning("‚ö†Ô∏è Digite uma API Key")

        with auth_tab2:
            st.subheader("Criar Novo Cliente")

            with st.form("novo_cliente"):
                nome = st.text_input("Nome da Empresa")
                email = st.text_input("Email")
                senha = st.text_input("Senha", type="password")
                plano = st.selectbox(
                    "Plano",
                    ["free", "basic", "premium"],
                    format_func=lambda x: {
                        "free": "üÜì Free (10 docs/m√™s)",
                        "basic": "üíº Basic (100 docs/m√™s)",
                        "premium": "‚≠ê Premium (1000 docs/m√™s)"
                    }[x]
                )

                if st.form_submit_button("‚ûï Criar Cliente", type="primary"):
                    if nome and email and senha:
                        with st.spinner("Criando cliente..."):
                            add_log(f"Criando cliente: {nome}")
                            success, result = create_client(
                                nome, email, senha, plano)
                            if success:
                                add_log(
                                    f"‚úÖ Cliente {nome} criado com sucesso!", "SUCCESS")
                                st.success("‚úÖ Cliente criado com sucesso!")
                                st.json(result)
                            else:
                                add_log(
                                    f"‚ùå Erro ao criar cliente: {result}", "ERROR")
                                st.error(f"‚ùå Erro ao criar cliente: {result}")
                    else:
                        st.warning("‚ö†Ô∏è Preencha todos os campos")

        # Logout
        if st.session_state.authenticated:
            st.markdown("---")
            if st.button("üö™ Logout", key="logout_button"):
                add_log("Logout realizado")
                st.session_state.api_key = None
                st.session_state.cliente_info = None
                st.session_state.authenticated = False
                st.success("‚úÖ Logout realizado!")
                st.rerun()

    # √Årea principal
    if not st.session_state.authenticated:
        st.info("üëÜ Use a sidebar para fazer login ou criar uma conta")
        return

    # Cliente autenticado
    if not st.session_state.cliente_info or 'cliente' not in st.session_state.cliente_info:
        st.error("‚ùå Dados do cliente n√£o dispon√≠veis")
        return

    cliente = st.session_state.cliente_info['cliente']

    # Header com informa√ß√µes do cliente
    col1, col2, col3 = st.columns([2, 2, 1])

    with col1:
        st.subheader(f"üë§ {cliente.get('nome', 'N/A')}")
        st.caption(f"üìß {cliente.get('email', 'N/A')}")

    with col2:
        st.subheader(f"üìã Plano: {cliente.get('plano', 'N/A').title()}")

        # Obter quotas
        success, quotas = get_client_quotas(st.session_state.api_key)
        if success and isinstance(quotas, dict):
            quota_data = quotas.get('quotas', {})
            if quota_data.get('documentos_restantes') is not None:
                st.metric("üìÑ Documentos Restantes", quota_data.get(
                    'documentos_restantes', 'N/A'))
            else:
                st.metric("üìÑ Documentos", "‚àû Ilimitado")
        else:
            st.warning("‚ö†Ô∏è N√£o foi poss√≠vel carregar quotas")

    with col3:
        st.subheader("üîë API Key")
        st.code(st.session_state.api_key[:20] + "...", language="text")

    # Tabs principais
    tab1, tab2, tab3, tab4, tab5 = st.tabs(
        ["üì§ Processar", "üìä Uso", "‚öôÔ∏è Configura√ß√µes", "üìà Relat√≥rios", "üìã Logs"])

    with tab1:
        st.header("üì§ Processar Documento")

        # Upload de arquivo
        uploaded_file = st.file_uploader(
            "Escolha um documento",
            type=['pdf', 'png', 'jpg', 'jpeg', 'tiff', 'bmp', 'txt', 'docx'],
            help="Formatos suportados: PDF, imagens, TXT, DOCX"
        )

        if uploaded_file is not None:
            st.success(f"Arquivo carregado: {uploaded_file.name}")
            st.info(f"**Tamanho:** {len(uploaded_file.getvalue())} bytes")

            # Bot√£o para processar
            if st.button("üöÄ Processar Documento", type="primary", disabled=st.session_state.processing, key="process_button"):
                st.session_state.processing = True
                clear_live_logs()  # Limpar logs anteriores

                with st.spinner("üîÑ Processando documento..."):
                    success, result = process_document_with_logs(
                        st.session_state.api_key, uploaded_file)

                    if success:
                        st.success("‚úÖ Documento processado com sucesso!")

                        # Mostrar resultado
                        if isinstance(result, dict):
                            result_str = json.dumps(
                                result, indent=2, ensure_ascii=False)
                            result_lang = "json"
                        else:
                            result_str = str(result)
                            result_lang = "text"

                        # Exibir resultado formatado
                        st.subheader("üìÑ Resultado do Processamento")
                        if result_lang == "json":
                            st.json(result)
                        else:
                            st.code(result_str, language="text")
                    else:
                        st.error(f"‚ùå Erro ao processar: {result}")

                st.session_state.processing = False

        # Se√ß√£o de logs sempre vis√≠vel
        st.markdown("---")
        st.subheader("üì° Logs da API")

        # Bot√µes de controle de logs
        col1, col2, col3 = st.columns(3)
        with col1:
            if st.button("üîç Capturar Logs", key="capture_logs"):
                add_live_log("üîç Capturando logs da API...", "INFO")
                docker_logs = get_docker_logs()

                if docker_logs:
                    for log in docker_logs:
                        add_live_log(log, "API")
                    add_live_log(
                        f"‚úÖ Capturados {len(docker_logs)} logs", "SUCCESS")
                else:
                    add_live_log("‚ÑπÔ∏è Nenhum log novo encontrado", "INFO")

                st.rerun()

        with col2:
            if st.button("üóëÔ∏è Limpar Logs", key="clear_live_logs"):
                clear_live_logs()
                st.rerun()

        with col3:
            if st.button("üìä Status API", key="api_status"):
                if check_api_health():
                    add_live_log("‚úÖ API funcionando normalmente", "SUCCESS")
                else:
                    add_live_log("‚ùå API indispon√≠vel", "ERROR")
                st.rerun()

        # Exibir logs
        display_live_logs()

    with tab2:
        st.header("üìä Uso e Quotas")

        # Carregar dados de uso
        if st.button("üîÑ Atualizar Dados", key="refresh_data_button"):
            with st.spinner("Carregando dados..."):
                add_log("Atualizando dados de uso...")
                success, usage_data = authenticate_client(
                    st.session_state.api_key)
                if success:
                    st.session_state.cliente_info = usage_data
                    add_log("‚úÖ Dados de uso atualizados!", "SUCCESS")
                    st.success("‚úÖ Dados atualizados!")
                    st.rerun()
                else:
                    add_log(
                        f"‚ùå Erro ao atualizar dados: {usage_data}", "ERROR")

        # Mostrar dados de uso
        if st.session_state.cliente_info:
            usage = st.session_state.cliente_info

            col1, col2 = st.columns(2)

            with col1:
                st.subheader("üìà Resumo")
                resumo = usage.get('resumo', {})
                st.metric("üîÑ Total Opera√ß√µes",
                          resumo.get('total_operacoes', 0))
                st.metric("üß† Tokens Consumidos",
                          f"{resumo.get('total_tokens', 0):,}")
                st.metric("üí∞ Custo Total",
                          f"R$ {resumo.get('total_custo', 0):.4f}")
                st.metric("‚è±Ô∏è Tempo M√©dio",
                          f"{resumo.get('tempo_medio', 0):.2f}s")

            with col2:
                st.subheader("üìã Quotas")
                quotas = usage.get('quotas', {})
                st.metric("üìÑ Documentos Usados",
                          f"{quotas.get('documentos_usados', 0)}/{quotas.get('documentos_mes', '‚àû')}")
                st.metric(
                    "üß† Tokens Usados", f"{quotas.get('tokens_usados', 0):,}/{quotas.get('tokens_mes', '‚àû'):,}")

                # Barra de progresso
                if quotas.get('documentos_mes') and quotas.get('documentos_mes') > 0:
                    progress = quotas.get(
                        'documentos_usados', 0) / quotas.get('documentos_mes', 1)
                    st.progress(progress)
                    st.caption(f"Progresso: {progress:.1%}")

    with tab3:
        st.header("‚öôÔ∏è Configura√ß√µes")

        # Upgrade de plano
        st.subheader("üîÑ Upgrade de Plano")

        current_plan = cliente['plano']
        available_plans = {
            "free": ["basic", "premium"],
            "basic": ["premium"],
            "premium": []
        }

        if current_plan in available_plans and available_plans[current_plan]:
            upgrade_options = available_plans[current_plan]
            novo_plano = st.selectbox(
                "Escolha o novo plano:",
                upgrade_options,
                format_func=lambda x: {
                    "basic": "üíº Basic (100 docs/m√™s, 100k tokens)",
                    "premium": "‚≠ê Premium (1000 docs/m√™s, 1M tokens)"
                }[x]
            )

            if st.button("üîÑ Fazer Upgrade", type="primary", key="upgrade_button"):
                with st.spinner("Fazendo upgrade..."):
                    add_log(f"Tentando upgrade para plano: {novo_plano}")
                    success, result = upgrade_plan(
                        st.session_state.api_key, novo_plano)
                    if success:
                        add_log(
                            f"‚úÖ Upgrade para {novo_plano} realizado com sucesso!", "SUCCESS")
                        st.success("‚úÖ Upgrade realizado com sucesso!")
                        st.json(result)
                        # Recarregar dados do cliente
                        time.sleep(1)
                        auth_success, new_data = authenticate_client(
                            st.session_state.api_key)
                        if auth_success:
                            st.session_state.cliente_info = new_data
                            st.rerun()
                    else:
                        add_log(f"‚ùå Erro no upgrade: {result}", "ERROR")
                        st.error(f"‚ùå Erro no upgrade: {result}")
        else:
            st.info("üéâ Voc√™ j√° est√° no plano mais alto dispon√≠vel!")

    with tab4:
        st.header("üìà Relat√≥rios Detalhados")

        if st.session_state.cliente_info:
            usage = st.session_state.cliente_info

            # Per√≠odo
            periodo = usage.get('periodo', {})
            st.subheader("üìÖ Per√≠odo de An√°lise")
            st.info(
                f"**Dias:** {periodo.get('dias', 0)} | **In√≠cio:** {periodo.get('inicio', 'N/A')} | **Fim:** {periodo.get('fim', 'N/A')}")

            # Uso por opera√ß√£o
            uso_por_operacao = usage.get('uso_por_operacao', [])
            if uso_por_operacao:
                st.subheader("üîÑ Uso por Opera√ß√£o")
                for op in uso_por_operacao:
                    st.write(
                        f"‚Ä¢ **{op.get('operacao', 'N/A')}:** {op.get('quantidade', 0)} opera√ß√µes")

            # Uso por provider
            uso_por_provider = usage.get('uso_por_provider', [])
            if uso_por_provider:
                st.subheader("üîß Uso por Provider")
                for prov in uso_por_provider:
                    st.write(
                        f"‚Ä¢ **{prov.get('provider', 'N/A')}:** {prov.get('quantidade', 0)} opera√ß√µes")

            if not uso_por_operacao and not uso_por_provider:
                st.info("üìä Nenhum dado de uso registrado ainda")

    with tab5:
        st.header("üìã Logs Hist√≥ricos")

        # Controles de log
        col1, col2 = st.columns([1, 4])
        with col1:
            if st.button("üóëÔ∏è Limpar Logs"):
                clear_logs()
                st.rerun()

        with col2:
            st.caption("Logs hist√≥ricos das opera√ß√µes")

        # Exibir logs
        if st.session_state.logs:
            # Container com scroll
            logs_container = st.container(height=400)
            with logs_container:
                # Colorir logs por n√≠vel
                for log in st.session_state.logs:
                    if "ERROR" in log:
                        st.error(log)
                    elif "SUCCESS" in log:
                        st.success(log)
                    elif "WARNING" in log:
                        st.warning(log)
                    else:
                        st.info(log)

            # Estat√≠sticas
            total_logs = len(st.session_state.logs)
            error_logs = len(
                [log for log in st.session_state.logs if "ERROR" in log])
            success_logs = len(
                [log for log in st.session_state.logs if "SUCCESS" in log])

            st.caption(
                f"üìä Total: {total_logs} | ‚úÖ Sucessos: {success_logs} | ‚ùå Erros: {error_logs}")
        else:
            st.info(
                "üìù Nenhum log registrado ainda. Execute opera√ß√µes para ver os logs.")

    # Footer
    st.markdown("---")
    st.markdown(
        "**ETL Documentos v2.0** | Sistema de Rastreabilidade Completo | Feito com ‚ù§Ô∏è e Streamlit")


if __name__ == "__main__":
    main()
